{"$message_type":"diagnostic","message":"failed to resolve: could not find `Surface` in `khr`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/bin/hlx_demo_cube.rs","byte_start":9313,"byte_end":9320,"line_start":243,"line_end":243,"column_start":48,"column_end":55,"is_primary":true,"text":[{"text":"    let surface_loader = ash::extensions::khr::Surface::new(&entry, &instance);","highlight_start":48,"highlight_end":55}],"label":"could not find `Surface` in `khr`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m: failed to resolve: could not find `Surface` in `khr`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/bin/hlx_demo_cube.rs:243:48\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m243\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let surface_loader = ash::extensions::khr::Surface::new(&entry, &instance);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcould not find `Surface` in `khr`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: could not find `Swapchain` in `khr`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/bin/hlx_demo_cube.rs","byte_start":11295,"byte_end":11304,"line_start":299,"line_end":299,"column_start":50,"column_end":59,"is_primary":true,"text":[{"text":"    let swapchain_loader = ash::extensions::khr::Swapchain::new(&instance, &device);","highlight_start":50,"highlight_end":59}],"label":"could not find `Swapchain` in `khr`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m: failed to resolve: could not find `Swapchain` in `khr`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/bin/hlx_demo_cube.rs:299:50\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m299\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let swapchain_loader = ash::extensions::khr::Swapchain::new(&instance, &device);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcould not find `Swapchain` in `khr`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"module `extensions` is private","code":{"code":"E0603","explanation":"A private item was used outside its scope.\n\nErroneous code example:\n\n```compile_fail,E0603\nmod foo {\n    const PRIVATE: u32 = 0x_a_bad_1dea_u32; // This const is private, so we\n                                            // can't use it outside of the\n                                            // `foo` module.\n}\n\nprintln!(\"const value: {}\", foo::PRIVATE); // error: constant `PRIVATE`\n                                                  //        is private\n```\n\nIn order to fix this error, you need to make the item public by using the `pub`\nkeyword. Example:\n\n```\nmod foo {\n    pub const PRIVATE: u32 = 0x_a_bad_1dea_u32; // We set it public by using the\n                                                // `pub` keyword.\n}\n\nprintln!(\"const value: {}\", foo::PRIVATE); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/bin/hlx_demo_cube.rs","byte_start":9296,"byte_end":9306,"line_start":243,"line_end":243,"column_start":31,"column_end":41,"is_primary":true,"text":[{"text":"    let surface_loader = ash::extensions::khr::Surface::new(&entry, &instance);","highlight_start":31,"highlight_end":41}],"label":"private module","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/bin/hlx_demo_cube.rs","byte_start":9308,"byte_end":9311,"line_start":243,"line_end":243,"column_start":43,"column_end":46,"is_primary":false,"text":[{"text":"    let surface_loader = ash::extensions::khr::Surface::new(&entry, &instance);","highlight_start":43,"highlight_end":46}],"label":"module `khr` is not publicly re-exported","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the module `extensions` is defined here","code":null,"level":"note","spans":[{"file_name":"/home/matt/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ash-0.38.0+1.3.281/src/lib.rs","byte_start":2230,"byte_end":2244,"line_start":78,"line_end":78,"column_start":1,"column_end":15,"is_primary":true,"text":[{"text":"mod extensions;","highlight_start":1,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0603]\u001b[0m\u001b[0m\u001b[1m: module `extensions` is private\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/bin/hlx_demo_cube.rs:243:31\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m243\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let surface_loader = ash::extensions::khr::Surface::new(&entry, &instance);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mmodule `khr` is not publicly re-exported\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mprivate module\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: the module `extensions` is defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/matt/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ash-0.38.0+1.3.281/src/lib.rs:78:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m78\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mmod extensions;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"module `extensions` is private","code":{"code":"E0603","explanation":"A private item was used outside its scope.\n\nErroneous code example:\n\n```compile_fail,E0603\nmod foo {\n    const PRIVATE: u32 = 0x_a_bad_1dea_u32; // This const is private, so we\n                                            // can't use it outside of the\n                                            // `foo` module.\n}\n\nprintln!(\"const value: {}\", foo::PRIVATE); // error: constant `PRIVATE`\n                                                  //        is private\n```\n\nIn order to fix this error, you need to make the item public by using the `pub`\nkeyword. Example:\n\n```\nmod foo {\n    pub const PRIVATE: u32 = 0x_a_bad_1dea_u32; // We set it public by using the\n                                                // `pub` keyword.\n}\n\nprintln!(\"const value: {}\", foo::PRIVATE); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/bin/hlx_demo_cube.rs","byte_start":11278,"byte_end":11288,"line_start":299,"line_end":299,"column_start":33,"column_end":43,"is_primary":true,"text":[{"text":"    let swapchain_loader = ash::extensions::khr::Swapchain::new(&instance, &device);","highlight_start":33,"highlight_end":43}],"label":"private module","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/bin/hlx_demo_cube.rs","byte_start":11290,"byte_end":11293,"line_start":299,"line_end":299,"column_start":45,"column_end":48,"is_primary":false,"text":[{"text":"    let swapchain_loader = ash::extensions::khr::Swapchain::new(&instance, &device);","highlight_start":45,"highlight_end":48}],"label":"module `khr` is not publicly re-exported","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the module `extensions` is defined here","code":null,"level":"note","spans":[{"file_name":"/home/matt/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ash-0.38.0+1.3.281/src/lib.rs","byte_start":2230,"byte_end":2244,"line_start":78,"line_end":78,"column_start":1,"column_end":15,"is_primary":true,"text":[{"text":"mod extensions;","highlight_start":1,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0603]\u001b[0m\u001b[0m\u001b[1m: module `extensions` is private\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/bin/hlx_demo_cube.rs:299:33\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m299\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let swapchain_loader = ash::extensions::khr::Swapchain::new(&instance, &device);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mmodule `khr` is not publicly re-exported\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mprivate module\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: the module `extensions` is defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/matt/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ash-0.38.0+1.3.281/src/lib.rs:78:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m78\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mmod extensions;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused imports: `Device` and `Instance`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/bin/hlx_demo_cube.rs","byte_start":528,"byte_end":536,"line_start":18,"line_end":18,"column_start":22,"column_end":30,"is_primary":true,"text":[{"text":"use ash::{vk, Entry, Instance, Device};","highlight_start":22,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/bin/hlx_demo_cube.rs","byte_start":538,"byte_end":544,"line_start":18,"line_end":18,"column_start":32,"column_end":38,"is_primary":true,"text":[{"text":"use ash::{vk, Entry, Instance, Device};","highlight_start":32,"highlight_end":38}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the unused imports","code":null,"level":"help","spans":[{"file_name":"src/bin/hlx_demo_cube.rs","byte_start":526,"byte_end":544,"line_start":18,"line_end":18,"column_start":20,"column_end":38,"is_primary":true,"text":[{"text":"use ash::{vk, Entry, Instance, Device};","highlight_start":20,"highlight_end":38}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused imports: `Device` and `Instance`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/bin/hlx_demo_cube.rs:18:22\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m18\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse ash::{vk, Entry, Instance, Device};\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `EventLoop<()>: raw_window_handle::HasRawWindowHandle` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/bin/hlx_demo_cube.rs","byte_start":8874,"byte_end":8885,"line_start":234,"line_end":234,"column_start":72,"column_end":83,"is_primary":true,"text":[{"text":"    let surface_extensions = ash_window::enumerate_required_extensions(&event_loop)?;","highlight_start":72,"highlight_end":83}],"label":"the trait `raw_window_handle::HasRawWindowHandle` is not implemented for `EventLoop<()>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there are multiple different versions of crate `raw_window_handle` in the dependency graph","code":null,"level":"note","spans":[{"file_name":"/home/matt/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/raw-window-handle-0.4.3/src/lib.rs","byte_start":2127,"byte_end":2162,"line_start":57,"line_end":57,"column_start":1,"column_end":36,"is_primary":true,"text":[{"text":"pub unsafe trait HasRawWindowHandle {","highlight_start":1,"highlight_end":36}],"label":"this is the required trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/bin/hlx_demo_cube.rs","byte_start":8832,"byte_end":8842,"line_start":234,"line_end":234,"column_start":30,"column_end":40,"is_primary":false,"text":[{"text":"    let surface_extensions = ash_window::enumerate_required_extensions(&event_loop)?;","highlight_start":30,"highlight_end":40}],"label":"one version of crate `raw_window_handle` used here, as a dependency of crate `ash_window`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/bin/hlx_demo_cube.rs","byte_start":598,"byte_end":603,"line_start":21,"line_end":21,"column_start":5,"column_end":10,"is_primary":false,"text":[{"text":"use winit::event_loop::{EventLoop, ControlFlow};","highlight_start":5,"highlight_end":10}],"label":"one version of crate `raw_window_handle` used here, as a dependency of crate `winit`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/matt/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/winit-0.28.7/src/event_loop.rs","byte_start":1533,"byte_end":1565,"line_start":35,"line_end":35,"column_start":1,"column_end":33,"is_primary":false,"text":[{"text":"pub struct EventLoop<T: 'static> {","highlight_start":1,"highlight_end":33}],"label":"this type doesn't implement the required trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/matt/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/raw-window-handle-0.5.2/src/borrowed.rs","byte_start":9641,"byte_end":9667,"line_start":227,"line_end":227,"column_start":1,"column_end":27,"is_primary":false,"text":[{"text":"pub trait HasDisplayHandle {","highlight_start":1,"highlight_end":27}],"label":"this is the found trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for the cast from `&EventLoop<()>` to `&dyn raw_window_handle::HasRawWindowHandle`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `EventLoop<()>: raw_window_handle::HasRawWindowHandle` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/bin/hlx_demo_cube.rs:234:72\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m234\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let surface_extensions = ash_window::enumerate_required_extensions(&event_loop)?;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `raw_window_handle::HasRawWindowHandle` is not implemented for `EventLoop<()>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: there are \u001b[0m\u001b[0m\u001b[1m\u001b[35mmultiple different versions\u001b[0m\u001b[0m of crate `\u001b[0m\u001b[0m\u001b[1m\u001b[35mraw_window_handle\u001b[0m\u001b[0m` in the dependency graph\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/matt/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/raw-window-handle-0.4.3/src/lib.rs:57:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m57\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub unsafe trait HasRawWindowHandle {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mthis is the required trait\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/bin/hlx_demo_cube.rs:21:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m21\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse winit::event_loop::{EventLoop, ControlFlow};\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-----\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mone version of crate `raw_window_handle` used here, as a dependency of crate `winit`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m234\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let surface_extensions = ash_window::enumerate_required_extensions(&event_loop)?;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mone version of crate `raw_window_handle` used here, as a dependency of crate `ash_window`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/home/matt/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/winit-0.28.7/src/event_loop.rs:35:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m35\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct EventLoop<T: 'static> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis type doesn't implement the required trait\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/home/matt/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/raw-window-handle-0.5.2/src/borrowed.rs:227:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m227\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait HasDisplayHandle {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis is the found trait\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: you can use `\u001b[0m\u001b[0m\u001b[1m\u001b[35mcargo tree\u001b[0m\u001b[0m` to explore your dependency tree\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for the cast from `&EventLoop<()>` to `&dyn raw_window_handle::HasRawWindowHandle`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `Window: raw_window_handle::HasRawWindowHandle` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/bin/hlx_demo_cube.rs","byte_start":9247,"byte_end":9254,"line_start":242,"line_end":242,"column_start":74,"column_end":81,"is_primary":true,"text":[{"text":"    let surface = unsafe { ash_window::create_surface(&entry, &instance, &window, None)? };","highlight_start":74,"highlight_end":81}],"label":"the trait `raw_window_handle::HasRawWindowHandle` is not implemented for `Window`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"trait impl with same name found","code":null,"level":"help","spans":[{"file_name":"/home/matt/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/winit-0.28.7/src/window.rs","byte_start":47985,"byte_end":48026,"line_start":1327,"line_end":1327,"column_start":1,"column_end":42,"is_primary":true,"text":[{"text":"unsafe impl HasRawWindowHandle for Window {","highlight_start":1,"highlight_end":42}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"perhaps two different versions of crate `raw_window_handle` are being used?","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"there are multiple different versions of crate `raw_window_handle` in the dependency graph","code":null,"level":"note","spans":[{"file_name":"/home/matt/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/raw-window-handle-0.4.3/src/lib.rs","byte_start":2127,"byte_end":2162,"line_start":57,"line_end":57,"column_start":1,"column_end":36,"is_primary":true,"text":[{"text":"pub unsafe trait HasRawWindowHandle {","highlight_start":1,"highlight_end":36}],"label":"this is the required trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/bin/hlx_demo_cube.rs","byte_start":8832,"byte_end":8842,"line_start":234,"line_end":234,"column_start":30,"column_end":40,"is_primary":false,"text":[{"text":"    let surface_extensions = ash_window::enumerate_required_extensions(&event_loop)?;","highlight_start":30,"highlight_end":40}],"label":"one version of crate `raw_window_handle` used here, as a dependency of crate `ash_window`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/bin/hlx_demo_cube.rs","byte_start":598,"byte_end":603,"line_start":21,"line_end":21,"column_start":5,"column_end":10,"is_primary":false,"text":[{"text":"use winit::event_loop::{EventLoop, ControlFlow};","highlight_start":5,"highlight_end":10}],"label":"one version of crate `raw_window_handle` used here, as a dependency of crate `winit`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/matt/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/winit-0.28.7/src/window.rs","byte_start":1025,"byte_end":1042,"line_start":44,"line_end":44,"column_start":1,"column_end":18,"is_primary":false,"text":[{"text":"pub struct Window {","highlight_start":1,"highlight_end":18}],"label":"this type doesn't implement the required trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/matt/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/raw-window-handle-0.5.2/src/borrowed.rs","byte_start":9641,"byte_end":9667,"line_start":227,"line_end":227,"column_start":1,"column_end":27,"is_primary":false,"text":[{"text":"pub trait HasDisplayHandle {","highlight_start":1,"highlight_end":27}],"label":"this is the found trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for the cast from `&Window` to `&dyn raw_window_handle::HasRawWindowHandle`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `Window: raw_window_handle::HasRawWindowHandle` is not satisfied\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/bin/hlx_demo_cube.rs:242:74\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m242\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let surface = unsafe { ash_window::create_surface(&entry, &instance, &window, None)? };\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `raw_window_handle::HasRawWindowHandle` is not implemented for `Window`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: trait impl with same name found\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/matt/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/winit-0.28.7/src/window.rs:1327:1\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1327\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0munsafe impl HasRawWindowHandle for Window {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: perhaps two different versions of crate `raw_window_handle` are being used?\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: there are \u001b[0m\u001b[0m\u001b[1m\u001b[35mmultiple different versions\u001b[0m\u001b[0m of crate `\u001b[0m\u001b[0m\u001b[1m\u001b[35mraw_window_handle\u001b[0m\u001b[0m` in the dependency graph\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/matt/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/raw-window-handle-0.4.3/src/lib.rs:57:1\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m57\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub unsafe trait HasRawWindowHandle {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mthis is the required trait\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/bin/hlx_demo_cube.rs:21:5\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m21\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse winit::event_loop::{EventLoop, ControlFlow};\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-----\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mone version of crate `raw_window_handle` used here, as a dependency of crate `winit`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m234\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let surface_extensions = ash_window::enumerate_required_extensions(&event_loop)?;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mone version of crate `raw_window_handle` used here, as a dependency of crate `ash_window`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/home/matt/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/winit-0.28.7/src/window.rs:44:1\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m44\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Window {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-----------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis type doesn't implement the required trait\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/home/matt/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/raw-window-handle-0.5.2/src/borrowed.rs:227:1\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m227\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait HasDisplayHandle {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis is the found trait\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: you can use `\u001b[0m\u001b[0m\u001b[1m\u001b[35mcargo tree\u001b[0m\u001b[0m` to explore your dependency tree\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for the cast from `&Window` to `&dyn raw_window_handle::HasRawWindowHandle`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"arguments to this function are incorrect","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/bin/hlx_demo_cube.rs","byte_start":9228,"byte_end":9234,"line_start":242,"line_end":242,"column_start":55,"column_end":61,"is_primary":false,"text":[{"text":"    let surface = unsafe { ash_window::create_surface(&entry, &instance, &window, None)? };","highlight_start":55,"highlight_end":61}],"label":"expected `ash::entry::Entry`, found `ash::Entry`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/bin/hlx_demo_cube.rs","byte_start":9236,"byte_end":9245,"line_start":242,"line_end":242,"column_start":63,"column_end":72,"is_primary":false,"text":[{"text":"    let surface = unsafe { ash_window::create_surface(&entry, &instance, &window, None)? };","highlight_start":63,"highlight_end":72}],"label":"expected `ash::instance::Instance`, found `ash::Instance`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/bin/hlx_demo_cube.rs","byte_start":9201,"byte_end":9227,"line_start":242,"line_end":242,"column_start":28,"column_end":54,"is_primary":true,"text":[{"text":"    let surface = unsafe { ash_window::create_surface(&entry, &instance, &window, None)? };","highlight_start":28,"highlight_end":54}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"two different versions of crate `ash` are being used; two types coming from two different versions of the same crate are different types even if they look the same","code":null,"level":"note","spans":[{"file_name":"/home/matt/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ash-0.37.3+1.3.251/src/entry.rs","byte_start":422,"byte_end":438,"line_start":20,"line_end":20,"column_start":1,"column_end":17,"is_primary":true,"text":[{"text":"pub struct Entry {","highlight_start":1,"highlight_end":17}],"label":"this is the expected type `ash::entry::Entry`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/matt/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ash-0.38.0+1.3.281/src/entry.rs","byte_start":336,"byte_end":352,"line_start":18,"line_end":18,"column_start":1,"column_end":17,"is_primary":true,"text":[{"text":"pub struct Entry {","highlight_start":1,"highlight_end":17}],"label":"this is the found type `ash::Entry`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/bin/hlx_demo_cube.rs","byte_start":8832,"byte_end":8842,"line_start":234,"line_end":234,"column_start":30,"column_end":40,"is_primary":false,"text":[{"text":"    let surface_extensions = ash_window::enumerate_required_extensions(&event_loop)?;","highlight_start":30,"highlight_end":40}],"label":"one version of crate `ash` used here, as a dependency of crate `ash_window`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/bin/hlx_demo_cube.rs","byte_start":511,"byte_end":514,"line_start":18,"line_end":18,"column_start":5,"column_end":8,"is_primary":false,"text":[{"text":"use ash::{vk, Entry, Instance, Device};","highlight_start":5,"highlight_end":8}],"label":"one version of crate `ash` used here, as a direct dependency of the current crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"two different versions of crate `ash` are being used; two types coming from two different versions of the same crate are different types even if they look the same","code":null,"level":"note","spans":[{"file_name":"/home/matt/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ash-0.37.3+1.3.251/src/instance.rs","byte_start":278,"byte_end":297,"line_start":13,"line_end":13,"column_start":1,"column_end":20,"is_primary":true,"text":[{"text":"pub struct Instance {","highlight_start":1,"highlight_end":20}],"label":"this is the expected type `ash::instance::Instance`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/matt/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ash-0.38.0+1.3.281/src/instance.rs","byte_start":286,"byte_end":305,"line_start":14,"line_end":14,"column_start":1,"column_end":20,"is_primary":true,"text":[{"text":"pub struct Instance {","highlight_start":1,"highlight_end":20}],"label":"this is the found type `ash::Instance`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/bin/hlx_demo_cube.rs","byte_start":8832,"byte_end":8842,"line_start":234,"line_end":234,"column_start":30,"column_end":40,"is_primary":false,"text":[{"text":"    let surface_extensions = ash_window::enumerate_required_extensions(&event_loop)?;","highlight_start":30,"highlight_end":40}],"label":"one version of crate `ash` used here, as a dependency of crate `ash_window`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/bin/hlx_demo_cube.rs","byte_start":511,"byte_end":514,"line_start":18,"line_end":18,"column_start":5,"column_end":8,"is_primary":false,"text":[{"text":"use ash::{vk, Entry, Instance, Device};","highlight_start":5,"highlight_end":8}],"label":"one version of crate `ash` used here, as a direct dependency of the current crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"/home/matt/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ash-window-0.11.0/src/lib.rs","byte_start":588,"byte_end":602,"line_start":21,"line_end":21,"column_start":15,"column_end":29,"is_primary":true,"text":[{"text":"pub unsafe fn create_surface(","highlight_start":15,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: arguments to this function are incorrect\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/bin/hlx_demo_cube.rs:242:28\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m242\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let surface = unsafe { ash_window::create_surface(&entry, &instance, &window, None)? };\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mexpected `ash::instance::Instance`, found `ash::Instance`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mexpected `ash::entry::Entry`, found `ash::Entry`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: two different versions of crate `ash` are being used; two types coming from two different versions of the same crate are different types even if they look the same\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/matt/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ash-0.38.0+1.3.281/src/entry.rs:18:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m18\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Entry {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mthis is the found type `ash::Entry`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/home/matt/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ash-0.37.3+1.3.251/src/entry.rs:20:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m20\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Entry {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mthis is the expected type `ash::entry::Entry`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/bin/hlx_demo_cube.rs:18:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m18\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse ash::{vk, Entry, Instance, Device};\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mone version of crate `ash` used here, as a direct dependency of the current crate\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m234\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let surface_extensions = ash_window::enumerate_required_extensions(&event_loop)?;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mone version of crate `ash` used here, as a dependency of crate `ash_window`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: you can use `cargo tree` to explore your dependency tree\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: two different versions of crate `ash` are being used; two types coming from two different versions of the same crate are different types even if they look the same\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/matt/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ash-0.38.0+1.3.281/src/instance.rs:14:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m14\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Instance {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mthis is the found type `ash::Instance`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/home/matt/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ash-0.37.3+1.3.251/src/instance.rs:13:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m13\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Instance {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mthis is the expected type `ash::instance::Instance`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/bin/hlx_demo_cube.rs:18:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m18\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse ash::{vk, Entry, Instance, Device};\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mone version of crate `ash` used here, as a direct dependency of the current crate\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m234\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let surface_extensions = ash_window::enumerate_required_extensions(&event_loop)?;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mone version of crate `ash` used here, as a dependency of crate `ash_window`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: you can use `cargo tree` to explore your dependency tree\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/matt/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ash-window-0.11.0/src/lib.rs:21:15\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m21\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub unsafe fn create_surface(\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/bin/hlx_demo_cube.rs","byte_start":11818,"byte_end":11825,"line_start":313,"line_end":313,"column_start":18,"column_end":25,"is_primary":true,"text":[{"text":"        .surface(surface)","highlight_start":18,"highlight_end":25}],"label":"expected `SurfaceKHR`, found `ash::vk::definitions::SurfaceKHR`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/bin/hlx_demo_cube.rs","byte_start":11810,"byte_end":11817,"line_start":313,"line_end":313,"column_start":10,"column_end":17,"is_primary":false,"text":[{"text":"        .surface(surface)","highlight_start":10,"highlight_end":17}],"label":"arguments to this method are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"two different versions of crate `ash` are being used; two types coming from two different versions of the same crate are different types even if they look the same","code":null,"level":"note","spans":[{"file_name":"/home/matt/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ash-0.38.0+1.3.281/src/vk/macros.rs","byte_start":2801,"byte_end":2823,"line_start":93,"line_end":93,"column_start":9,"column_end":31,"is_primary":true,"text":[{"text":"        pub struct $name(u64);","highlight_start":9,"highlight_end":31}],"label":"this is the expected type `SurfaceKHR`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/matt/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ash-0.38.0+1.3.281/src/vk/definitions.rs","byte_start":27126,"byte_end":27283,"line_start":491,"line_end":495,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"handle_nondispatchable!(","highlight_start":1,"highlight_end":1},{"text":"    SurfaceKHR,","highlight_start":1,"highlight_end":1},{"text":"    SURFACE_KHR,","highlight_start":1,"highlight_end":1},{"text":"    doc = \"<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSurfaceKHR.html>\"","highlight_start":1,"highlight_end":1},{"text":");","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"handle_nondispatchable!","def_site_span":{"file_name":"/home/matt/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ash-0.38.0+1.3.281/src/vk/macros.rs","byte_start":2463,"byte_end":2498,"line_start":85,"line_end":85,"column_start":1,"column_end":36,"is_primary":false,"text":[{"text":"macro_rules! handle_nondispatchable {","highlight_start":1,"highlight_end":36}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"/home/matt/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ash-0.37.3+1.3.251/src/vk/macros.rs","byte_start":2794,"byte_end":2816,"line_start":93,"line_end":93,"column_start":9,"column_end":31,"is_primary":true,"text":[{"text":"        pub struct $name(u64);","highlight_start":9,"highlight_end":31}],"label":"this is the found type `ash::vk::definitions::SurfaceKHR`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/matt/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ash-0.37.3+1.3.251/src/vk/definitions.rs","byte_start":28272,"byte_end":28441,"line_start":448,"line_end":453,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"handle_nondispatchable!(","highlight_start":1,"highlight_end":1},{"text":"    SurfaceKHR,","highlight_start":1,"highlight_end":1},{"text":"    SURFACE_KHR,","highlight_start":1,"highlight_end":1},{"text":"    doc =","highlight_start":1,"highlight_end":1},{"text":"        \"<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSurfaceKHR.html>\"","highlight_start":1,"highlight_end":1},{"text":");","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"handle_nondispatchable!","def_site_span":{"file_name":"/home/matt/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ash-0.37.3+1.3.251/src/vk/macros.rs","byte_start":2456,"byte_end":2491,"line_start":85,"line_end":85,"column_start":1,"column_end":36,"is_primary":false,"text":[{"text":"macro_rules! handle_nondispatchable {","highlight_start":1,"highlight_end":36}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/bin/hlx_demo_cube.rs","byte_start":511,"byte_end":514,"line_start":18,"line_end":18,"column_start":5,"column_end":8,"is_primary":false,"text":[{"text":"use ash::{vk, Entry, Instance, Device};","highlight_start":5,"highlight_end":8}],"label":"one version of crate `ash` used here, as a direct dependency of the current crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/bin/hlx_demo_cube.rs","byte_start":8832,"byte_end":8842,"line_start":234,"line_end":234,"column_start":30,"column_end":40,"is_primary":false,"text":[{"text":"    let surface_extensions = ash_window::enumerate_required_extensions(&event_loop)?;","highlight_start":30,"highlight_end":40}],"label":"one version of crate `ash` used here, as a dependency of crate `ash_window`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"method defined here","code":null,"level":"note","spans":[{"file_name":"/home/matt/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ash-0.38.0+1.3.281/src/vk/definitions.rs","byte_start":327210,"byte_end":327217,"line_start":9024,"line_end":9024,"column_start":12,"column_end":19,"is_primary":true,"text":[{"text":"    pub fn surface(mut self, surface: SurfaceKHR) -> Self {","highlight_start":12,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/bin/hlx_demo_cube.rs:313:18\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m313\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        .surface(surface)\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `SurfaceKHR`, found `ash::vk::definitions::SurfaceKHR`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12marguments to this method are incorrect\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: two different versions of crate `ash` are being used; two types coming from two different versions of the same crate are different types even if they look the same\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/matt/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ash-0.38.0+1.3.281/src/vk/definitions.rs:491:1\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m491\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mhandle_nondispatchable!(\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m492\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    SurfaceKHR,\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m493\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    SURFACE_KHR,\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m494\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    doc = \"<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSurfaceKHR.html>\"\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m495\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|_^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mthis is the expected type `SurfaceKHR`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/home/matt/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ash-0.37.3+1.3.251/src/vk/definitions.rs:448:1\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m448\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mhandle_nondispatchable!(\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m449\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    SurfaceKHR,\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m450\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    SURFACE_KHR,\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m451\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    doc =\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m452\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        \"<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSurfaceKHR.html>\"\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m453\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|_^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mthis is the found type `ash::vk::definitions::SurfaceKHR`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/bin/hlx_demo_cube.rs:18:5\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m18\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0muse ash::{vk, Entry, Instance, Device};\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mone version of crate `ash` used here, as a direct dependency of the current crate\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m234\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m    let surface_extensions = ash_window::enumerate_required_extensions(&event_loop)?;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mone version of crate `ash` used here, as a dependency of crate `ash_window`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: you can use `cargo tree` to explore your dependency tree\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: method defined here\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/matt/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ash-0.38.0+1.3.281/src/vk/definitions.rs:9024:12\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m9024\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn surface(mut self, surface: SurfaceKHR) -> Self {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `handle_nondispatchable` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `map_err` found for type `!` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/bin/hlx_demo_cube.rs","byte_start":12868,"byte_end":17350,"line_start":338,"line_end":438,"column_start":5,"column_end":8,"is_primary":false,"text":[{"text":"    event_loop.run(move |event, target, control_flow| {","highlight_start":5,"highlight_end":56},{"text":"        *control_flow = ControlFlow::Poll;","highlight_start":1,"highlight_end":43},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        match event {","highlight_start":1,"highlight_end":22},{"text":"            Event::WindowEvent { event, .. } => match event {","highlight_start":1,"highlight_end":62},{"text":"                WindowEvent::CloseRequested => *control_flow = ControlFlow::Exit,","highlight_start":1,"highlight_end":82},{"text":"                WindowEvent::KeyboardInput { input, .. } => {","highlight_start":1,"highlight_end":62},{"text":"                    if let KeyboardInput {","highlight_start":1,"highlight_end":43},{"text":"                        state: ElementState::Pressed,","highlight_start":1,"highlight_end":54},{"text":"                        virtual_keycode: Some(VirtualKeyCode::Escape),","highlight_start":1,"highlight_end":71},{"text":"                        ..","highlight_start":1,"highlight_end":27},{"text":"                    } = input","highlight_start":1,"highlight_end":30},{"text":"                    {","highlight_start":1,"highlight_end":22},{"text":"                        *control_flow = ControlFlow::Exit;","highlight_start":1,"highlight_end":59},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                _ => {}","highlight_start":1,"highlight_end":24},{"text":"            },","highlight_start":1,"highlight_end":15},{"text":"            Event::MainEventsCleared => {","highlight_start":1,"highlight_end":42},{"text":"                let frame_start = Instant::now();","highlight_start":1,"highlight_end":50},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // Calculate rotation angle (deterministic based on frame number)","highlight_start":1,"highlight_end":82},{"text":"                let rotation = (frame_count as f32) * 0.02;","highlight_start":1,"highlight_end":60},{"text":"                let _push = PushConstants {","highlight_start":1,"highlight_end":44},{"text":"                    rotation_angle: rotation,","highlight_start":1,"highlight_end":46},{"text":"                    time: frame_count as f32 * 0.016,","highlight_start":1,"highlight_end":54},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // Acquire next swapchain image","highlight_start":1,"highlight_end":48},{"text":"                let image_index = match unsafe {","highlight_start":1,"highlight_end":49},{"text":"                    swapchain_loader.acquire_next_image(","highlight_start":1,"highlight_end":57},{"text":"                        swapchain,","highlight_start":1,"highlight_end":35},{"text":"                        u64::MAX,","highlight_start":1,"highlight_end":34},{"text":"                        vk::Semaphore::null(),","highlight_start":1,"highlight_end":47},{"text":"                        vk::Fence::null(),","highlight_start":1,"highlight_end":43},{"text":"                    )","highlight_start":1,"highlight_end":22},{"text":"                } {","highlight_start":1,"highlight_end":20},{"text":"                    Ok((idx, _)) => idx,","highlight_start":1,"highlight_end":41},{"text":"                    Err(_) => {","highlight_start":1,"highlight_end":32},{"text":"                        // Swapchain out of date, would need to recreate","highlight_start":1,"highlight_end":73},{"text":"                        return;","highlight_start":1,"highlight_end":32},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // Present the frame","highlight_start":1,"highlight_end":37},{"text":"                let present_info = vk::PresentInfoKHR::default()","highlight_start":1,"highlight_end":65},{"text":"                    .wait_semaphores(&[])","highlight_start":1,"highlight_end":42},{"text":"                    .swapchains(std::slice::from_ref(&swapchain))","highlight_start":1,"highlight_end":66},{"text":"                    .image_indices(std::slice::from_ref(&image_index));","highlight_start":1,"highlight_end":72},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let _ = unsafe { swapchain_loader.queue_present(queue, &present_info) };","highlight_start":1,"highlight_end":89},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                frame_count += 1;","highlight_start":1,"highlight_end":34},{"text":"                let frame_time = frame_start.elapsed().as_micros();","highlight_start":1,"highlight_end":68},{"text":"                frame_times.push(frame_time);","highlight_start":1,"highlight_end":46},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // Print stats every 60 frames","highlight_start":1,"highlight_end":47},{"text":"                if frame_count % 60 == 0 {","highlight_start":1,"highlight_end":43},{"text":"                    let avg_frame_time = frame_times.iter().sum::<u128>() / frame_times.len() as u128;","highlight_start":1,"highlight_end":103},{"text":"                    let theoretical_fps = 1_000_000.0 / avg_frame_time as f64;","highlight_start":1,"highlight_end":79},{"text":"                    println!(\"Frame {}: {:.1} FPS (avg frame time: {}us)\", frame_count, theoretical_fps, avg_frame_time);","highlight_start":1,"highlight_end":122},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"            Event::LoopDestroyed => {","highlight_start":1,"highlight_end":38},{"text":"                // Cleanup","highlight_start":1,"highlight_end":27},{"text":"                println!(\"\\nCleaning up Vulkan resources...\");","highlight_start":1,"highlight_end":63},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    swapchain_loader.destroy_swapchain(swapchain, None);","highlight_start":1,"highlight_end":73},{"text":"                    device.destroy_device(None);","highlight_start":1,"highlight_end":49},{"text":"                    surface_loader.destroy_surface(surface, None);","highlight_start":1,"highlight_end":67},{"text":"                    instance.destroy_instance(None);","highlight_start":1,"highlight_end":53},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let total_time = start.elapsed();","highlight_start":1,"highlight_end":50},{"text":"                let avg_frame_time = if frame_times.is_empty() { 0 } else {","highlight_start":1,"highlight_end":76},{"text":"                    frame_times.iter().sum::<u128>() / frame_times.len() as u128","highlight_start":1,"highlight_end":81},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let theoretical_fps = if avg_frame_time > 0 {","highlight_start":1,"highlight_end":62},{"text":"                    1_000_000.0 / avg_frame_time as f64","highlight_start":1,"highlight_end":56},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    0.0","highlight_start":1,"highlight_end":24},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                println!(\"\\n========================================\");","highlight_start":1,"highlight_end":72},{"text":"                println!(\"Render session complete:\");","highlight_start":1,"highlight_end":54},{"text":"                println!(\"========================================\");","highlight_start":1,"highlight_end":70},{"text":"                println!(\"Total frames: {}\", frame_count);","highlight_start":1,"highlight_end":59},{"text":"                println!(\"Total time: {:?}\", total_time);","highlight_start":1,"highlight_end":58},{"text":"                println!(\"Avg frame time: {}us\", avg_frame_time);","highlight_start":1,"highlight_end":66},{"text":"                println!(\"Average FPS: {:.1}\", theoretical_fps);","highlight_start":1,"highlight_end":65},{"text":"                println!(\"\\nCONTRACT_1000 Verification Summary:\");","highlight_start":1,"highlight_end":67},{"text":"                println!(\"[PASS] A1 DETERMINISM: Same shader -> same handle\");","highlight_start":1,"highlight_end":79},{"text":"                println!(\"[PASS] A2 REVERSIBILITY: resolve(collapse(x)) = x\");","highlight_start":1,"highlight_end":79},{"text":"                println!(\"[PASS] INV-001 TOTAL_FIDELITY: Pipeline round-trip\");","highlight_start":1,"highlight_end":80},{"text":"                println!(\"[PASS] INV-002 HANDLE_IDEMPOTENCE: Consistent IDs\");","highlight_start":1,"highlight_end":79},{"text":"                println!(\"[PASS] INV-003 FIELD_ORDER: @0 < @1 < @2 < @3\");","highlight_start":1,"highlight_end":75},{"text":"                println!(\"========================================\");","highlight_start":1,"highlight_end":70},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"            _ => {}","highlight_start":1,"highlight_end":20},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }).map_err(|e| format!(\"Event loop error: {}\", e))?;","highlight_start":1,"highlight_end":8}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/bin/hlx_demo_cube.rs","byte_start":17350,"byte_end":17357,"line_start":438,"line_end":438,"column_start":8,"column_end":15,"is_primary":true,"text":[{"text":"    }).map_err(|e| format!(\"Event loop error: {}\", e))?;","highlight_start":8,"highlight_end":15}],"label":"method not found in `!`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `map_err` found for type `!` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/bin/hlx_demo_cube.rs:438:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m338\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m    event_loop.run(move |event, target, control_flow| {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m339\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        *control_flow = ControlFlow::Poll;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m340\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m341\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        match event {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m438\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }).map_err(|e| format!(\"Event loop error: {}\", e))?;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod not found in `!`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_______|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unreachable expression","code":{"code":"unreachable_code","explanation":null},"level":"warning","spans":[{"file_name":"src/bin/hlx_demo_cube.rs","byte_start":17358,"byte_end":17396,"line_start":438,"line_end":438,"column_start":16,"column_end":54,"is_primary":true,"text":[{"text":"    }).map_err(|e| format!(\"Event loop error: {}\", e))?;","highlight_start":16,"highlight_end":54}],"label":"unreachable expression","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/bin/hlx_demo_cube.rs","byte_start":12868,"byte_end":17349,"line_start":338,"line_end":438,"column_start":5,"column_end":7,"is_primary":false,"text":[{"text":"    event_loop.run(move |event, target, control_flow| {","highlight_start":5,"highlight_end":56},{"text":"        *control_flow = ControlFlow::Poll;","highlight_start":1,"highlight_end":43},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        match event {","highlight_start":1,"highlight_end":22},{"text":"            Event::WindowEvent { event, .. } => match event {","highlight_start":1,"highlight_end":62},{"text":"                WindowEvent::CloseRequested => *control_flow = ControlFlow::Exit,","highlight_start":1,"highlight_end":82},{"text":"                WindowEvent::KeyboardInput { input, .. } => {","highlight_start":1,"highlight_end":62},{"text":"                    if let KeyboardInput {","highlight_start":1,"highlight_end":43},{"text":"                        state: ElementState::Pressed,","highlight_start":1,"highlight_end":54},{"text":"                        virtual_keycode: Some(VirtualKeyCode::Escape),","highlight_start":1,"highlight_end":71},{"text":"                        ..","highlight_start":1,"highlight_end":27},{"text":"                    } = input","highlight_start":1,"highlight_end":30},{"text":"                    {","highlight_start":1,"highlight_end":22},{"text":"                        *control_flow = ControlFlow::Exit;","highlight_start":1,"highlight_end":59},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                _ => {}","highlight_start":1,"highlight_end":24},{"text":"            },","highlight_start":1,"highlight_end":15},{"text":"            Event::MainEventsCleared => {","highlight_start":1,"highlight_end":42},{"text":"                let frame_start = Instant::now();","highlight_start":1,"highlight_end":50},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // Calculate rotation angle (deterministic based on frame number)","highlight_start":1,"highlight_end":82},{"text":"                let rotation = (frame_count as f32) * 0.02;","highlight_start":1,"highlight_end":60},{"text":"                let _push = PushConstants {","highlight_start":1,"highlight_end":44},{"text":"                    rotation_angle: rotation,","highlight_start":1,"highlight_end":46},{"text":"                    time: frame_count as f32 * 0.016,","highlight_start":1,"highlight_end":54},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // Acquire next swapchain image","highlight_start":1,"highlight_end":48},{"text":"                let image_index = match unsafe {","highlight_start":1,"highlight_end":49},{"text":"                    swapchain_loader.acquire_next_image(","highlight_start":1,"highlight_end":57},{"text":"                        swapchain,","highlight_start":1,"highlight_end":35},{"text":"                        u64::MAX,","highlight_start":1,"highlight_end":34},{"text":"                        vk::Semaphore::null(),","highlight_start":1,"highlight_end":47},{"text":"                        vk::Fence::null(),","highlight_start":1,"highlight_end":43},{"text":"                    )","highlight_start":1,"highlight_end":22},{"text":"                } {","highlight_start":1,"highlight_end":20},{"text":"                    Ok((idx, _)) => idx,","highlight_start":1,"highlight_end":41},{"text":"                    Err(_) => {","highlight_start":1,"highlight_end":32},{"text":"                        // Swapchain out of date, would need to recreate","highlight_start":1,"highlight_end":73},{"text":"                        return;","highlight_start":1,"highlight_end":32},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // Present the frame","highlight_start":1,"highlight_end":37},{"text":"                let present_info = vk::PresentInfoKHR::default()","highlight_start":1,"highlight_end":65},{"text":"                    .wait_semaphores(&[])","highlight_start":1,"highlight_end":42},{"text":"                    .swapchains(std::slice::from_ref(&swapchain))","highlight_start":1,"highlight_end":66},{"text":"                    .image_indices(std::slice::from_ref(&image_index));","highlight_start":1,"highlight_end":72},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let _ = unsafe { swapchain_loader.queue_present(queue, &present_info) };","highlight_start":1,"highlight_end":89},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                frame_count += 1;","highlight_start":1,"highlight_end":34},{"text":"                let frame_time = frame_start.elapsed().as_micros();","highlight_start":1,"highlight_end":68},{"text":"                frame_times.push(frame_time);","highlight_start":1,"highlight_end":46},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // Print stats every 60 frames","highlight_start":1,"highlight_end":47},{"text":"                if frame_count % 60 == 0 {","highlight_start":1,"highlight_end":43},{"text":"                    let avg_frame_time = frame_times.iter().sum::<u128>() / frame_times.len() as u128;","highlight_start":1,"highlight_end":103},{"text":"                    let theoretical_fps = 1_000_000.0 / avg_frame_time as f64;","highlight_start":1,"highlight_end":79},{"text":"                    println!(\"Frame {}: {:.1} FPS (avg frame time: {}us)\", frame_count, theoretical_fps, avg_frame_time);","highlight_start":1,"highlight_end":122},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"            Event::LoopDestroyed => {","highlight_start":1,"highlight_end":38},{"text":"                // Cleanup","highlight_start":1,"highlight_end":27},{"text":"                println!(\"\\nCleaning up Vulkan resources...\");","highlight_start":1,"highlight_end":63},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    swapchain_loader.destroy_swapchain(swapchain, None);","highlight_start":1,"highlight_end":73},{"text":"                    device.destroy_device(None);","highlight_start":1,"highlight_end":49},{"text":"                    surface_loader.destroy_surface(surface, None);","highlight_start":1,"highlight_end":67},{"text":"                    instance.destroy_instance(None);","highlight_start":1,"highlight_end":53},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let total_time = start.elapsed();","highlight_start":1,"highlight_end":50},{"text":"                let avg_frame_time = if frame_times.is_empty() { 0 } else {","highlight_start":1,"highlight_end":76},{"text":"                    frame_times.iter().sum::<u128>() / frame_times.len() as u128","highlight_start":1,"highlight_end":81},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let theoretical_fps = if avg_frame_time > 0 {","highlight_start":1,"highlight_end":62},{"text":"                    1_000_000.0 / avg_frame_time as f64","highlight_start":1,"highlight_end":56},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    0.0","highlight_start":1,"highlight_end":24},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                println!(\"\\n========================================\");","highlight_start":1,"highlight_end":72},{"text":"                println!(\"Render session complete:\");","highlight_start":1,"highlight_end":54},{"text":"                println!(\"========================================\");","highlight_start":1,"highlight_end":70},{"text":"                println!(\"Total frames: {}\", frame_count);","highlight_start":1,"highlight_end":59},{"text":"                println!(\"Total time: {:?}\", total_time);","highlight_start":1,"highlight_end":58},{"text":"                println!(\"Avg frame time: {}us\", avg_frame_time);","highlight_start":1,"highlight_end":66},{"text":"                println!(\"Average FPS: {:.1}\", theoretical_fps);","highlight_start":1,"highlight_end":65},{"text":"                println!(\"\\nCONTRACT_1000 Verification Summary:\");","highlight_start":1,"highlight_end":67},{"text":"                println!(\"[PASS] A1 DETERMINISM: Same shader -> same handle\");","highlight_start":1,"highlight_end":79},{"text":"                println!(\"[PASS] A2 REVERSIBILITY: resolve(collapse(x)) = x\");","highlight_start":1,"highlight_end":79},{"text":"                println!(\"[PASS] INV-001 TOTAL_FIDELITY: Pipeline round-trip\");","highlight_start":1,"highlight_end":80},{"text":"                println!(\"[PASS] INV-002 HANDLE_IDEMPOTENCE: Consistent IDs\");","highlight_start":1,"highlight_end":79},{"text":"                println!(\"[PASS] INV-003 FIELD_ORDER: @0 < @1 < @2 < @3\");","highlight_start":1,"highlight_end":75},{"text":"                println!(\"========================================\");","highlight_start":1,"highlight_end":70},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"            _ => {}","highlight_start":1,"highlight_end":20},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }).map_err(|e| format!(\"Event loop error: {}\", e))?;","highlight_start":1,"highlight_end":7}],"label":"any code following this expression is unreachable","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unreachable_code)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unreachable expression\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/bin/hlx_demo_cube.rs:438:16\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m338\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m    event_loop.run(move |event, target, control_flow| {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m339\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        *control_flow = ControlFlow::Poll;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m340\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m341\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        match event {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m438\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }).map_err(|e| format!(\"Event loop error: {}\", e))?;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33munreachable expression\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|______|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12many code following this expression is unreachable\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(unreachable_code)]` (part of `#[warn(unused)]`) on by default\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 9 previous errors; 2 warnings emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 9 previous errors; 2 warnings emitted\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0277, E0308, E0433, E0599, E0603.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mSome errors have detailed explanations: E0277, E0308, E0433, E0599, E0603.\u001b[0m\n"}
{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0277`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about an error, try `rustc --explain E0277`.\u001b[0m\n"}
